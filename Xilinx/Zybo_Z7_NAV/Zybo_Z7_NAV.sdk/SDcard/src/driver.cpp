/*
 * driver.cpp
 *
 *  Created on: Mar 31, 2018
 *      Author: toni
 */

#include "driver.h"

/*
 * Define a function to wrap all run-once API initialization function calls for the HLS block.
 */
int hls_madgwick_init(XMadgwick *hls_madgwickPtr){
	XMadgwick_Config *cfgPtr;
	int status;
	cfgPtr = XMadgwick_LookupConfig(XPAR_MADGWICK_0_DEVICE_ID);	//Obtain the configuration information of the device by ID.
	if (!cfgPtr) {
		print("ERROR: Lookup of accelerator configuration failed.\n\r");
		return XST_FAILURE;
	}
	/*
	 * Initialize a device when an MMU is used in the system. In such a case the effective address
	 * of the AXI4-Lite slave is different from that defined in xparameters.h and API is required to
	 * initialize the device.
	 */
	status = XMadgwick_CfgInitialize(hls_madgwickPtr, cfgPtr);
	if (status != XST_SUCCESS) {
		print("ERROR: Could not initialize accelerator.\n\r");
		return XST_FAILURE;
	}
	return status;
}

/*
 * Define a helper function to wrap the HLS block API calls required to enable its interrupt
 * and start the block.
 */
void hls_madgwick_start(void *InstancePtr){
	XMadgwick *pAccelerator = (XMadgwick *)InstancePtr; //hold the IP instance pointer
	/*
	 * Enable the interrupt source. There may be at most 2 interrupt sources (source 0 for ap_done
	 * and source 1 for ap_ready)
	 */
	XMadgwick_InterruptEnable(pAccelerator,1);
	/*
	 * Enable the interrupt output. Interrupt functions are available only if there is ap_start.
	 */
	XMadgwick_InterruptGlobalEnable(pAccelerator);
	/*
	 * Start the device. This function will assert the ap_start port on the device. Available only
	 * if there is ap_start port on the device
	 */
	XMadgwick_Start(pAccelerator);
}

/*
 * An interrupt service routine is required in order for the processor to respond to an interrupt
 * generated by a peripheral.
 *
 * Each peripheral with an interrupt attached to the PS must have an ISR defined and
 * registered with the PS’s interrupt handler.
 *
 * The ISR is responsible for clearing the peripheral’s interrupt and, in this example, setting a
 * flag that indicates that a result is available for retrieval from the peripheral. In general, ISRs
 * should be designed to be lightweight and as fast as possible, essentially doing the
 * minimum necessary to service the interrupt. Tasks such as retrieving the data should be left
 * to the main application code.
 */
void hls_macc_isr(void *InstancePtr){
	XMadgwick *pAccelerator = (XMadgwick *)InstancePtr;
	//Disable the global interrupt
	XMadgwick_InterruptGlobalDisable(pAccelerator);
	//Disable the local interrupt
	XMadgwick_InterruptDisable(pAccelerator,0xffffffff);
	// clear the local interrupt
	XMadgwick_InterruptClear(pAccelerator,1);
	ResultAvailHlsMadgwick = 1;
	// restart the core if it should run again
	if(RunHlsMadgwick){
		hls_madgwick_start(pAccelerator);
	}
}

/*
 * Define a routine to setup the PS interrupt handler and register the HLS peripheral’s ISR.
 */
int setup_interrupt(XScuGic _ScuGic, XMadgwick _HlsMadgwick){
	//This functions sets up the interrupt on the ARM
	int result;
	XScuGic_Config *pCfg = XScuGic_LookupConfig(XPAR_SCUGIC_SINGLE_DEVICE_ID);
	if (pCfg == NULL){
		print("Interrupt Configuration Lookup Failed\n\r");
		return XST_FAILURE;
	}
	result = XScuGic_CfgInitialize(&_ScuGic,pCfg,pCfg->CpuBaseAddress);

	if(result != XST_SUCCESS){
		return result;
	}

	// self-test
	result = XScuGic_SelfTest(&_ScuGic);
	if(result != XST_SUCCESS){
		return result;
	}

	// Initialize the exception handler
	Xil_ExceptionInit();
	// Register the exception handler
	//print("Register the exception handler\n\r");
	Xil_ExceptionRegisterHandler(XIL_EXCEPTION_ID_INT, (Xil_ExceptionHandler)XScuGic_InterruptHandler,&_ScuGic);
	//Enable the exception handler
	Xil_ExceptionEnable();
	// Connect the Adder ISR to the exception table
	//print("Connect the Adder ISR to the Exception handler table\n\r");
	result = XScuGic_Connect(&_ScuGic, XPAR_FABRIC_MADGWICK_0_INTERRUPT_INTR,
	(Xil_InterruptHandler)hls_macc_isr,&_HlsMadgwick);

	if(result != XST_SUCCESS){
		return result;
	}

	//print("Enable the Adder ISR\n\r");
	XScuGic_Enable(&_ScuGic,XPAR_FABRIC_MADGWICK_0_INTERRUPT_INTR);
	return XST_SUCCESS;
}

/*
 *send gyroscope float data to coprosessor
 */
u32 XMadgwick_Writef_g_Words(XMadgwick *InstancePtr, int offset, float *data, int length){
    char* buffer;
	Xil_AssertNonvoid(InstancePtr != NULL);
    Xil_AssertNonvoid(InstancePtr -> IsReady == XIL_COMPONENT_IS_READY);

    int i;

    if ((offset + length)*4 > (XMADGWICK_COPROCESSOR_BUS_ADDR_G_HIGH - XMADGWICK_COPROCESSOR_BUS_ADDR_G_BASE + 1))
        return 0;
    xil_printf("\ngyro : \t\t");
    for (i = 0; i < length; i++) {
        *(float *)(InstancePtr->Coprocessor_bus_BaseAddress + XMADGWICK_COPROCESSOR_BUS_ADDR_G_BASE + (offset + i)*4) = *(data + i);
//        xil_printf("%f\t\t", *(data + i));
        sprintf(buffer, "%f\t\t", *(data + i));
        print(buffer);
    }
    return length;
}

/*
 *request gyroscope float data from coprosessor
 */
u32 XMadgwick_Readf_g_Words(XMadgwick *InstancePtr, int offset, float *data, int length){
    Xil_AssertNonvoid(InstancePtr != NULL);
    Xil_AssertNonvoid(InstancePtr -> IsReady == XIL_COMPONENT_IS_READY);

    int i;

    if ((offset + length)*4 > (XMADGWICK_COPROCESSOR_BUS_ADDR_G_HIGH - XMADGWICK_COPROCESSOR_BUS_ADDR_G_BASE + 1))
        return 0;

    for (i = 0; i < length; i++) {
        *(data + i) = *(float *)(InstancePtr->Coprocessor_bus_BaseAddress + XMADGWICK_COPROCESSOR_BUS_ADDR_G_BASE + (offset + i)*4);
    }
    return length;
}


/*
 *send accelerometer float data to coprosessor
 */
u32 XMadgwick_Writef_a_Words(XMadgwick *InstancePtr, int offset, float *data, int length){
	char *buffer;
    Xil_AssertNonvoid(InstancePtr != NULL);
    Xil_AssertNonvoid(InstancePtr -> IsReady == XIL_COMPONENT_IS_READY);

    int i;

    if ((offset + length)*4 > (XMADGWICK_COPROCESSOR_BUS_ADDR_A_HIGH - XMADGWICK_COPROCESSOR_BUS_ADDR_A_BASE + 1))
        return 0;

    xil_printf("\naccel : \t\t");
    for (i = 0; i < length; i++) {
        *(float *)(InstancePtr->Coprocessor_bus_BaseAddress + XMADGWICK_COPROCESSOR_BUS_ADDR_A_BASE + (offset + i)*4) = *(data + i);
//        xil_printf("%f\t\t", *(data + i));
        sprintf(buffer, "%f\t\t", *(data + i));
        print(buffer);
    }
    return length;
}


/*
 *request accelerometer float data from coprosessor
 */
u32 XMadgwick_Readf_a_Words(XMadgwick *InstancePtr, int offset, float *data, int length);


/*
 *send magnetometer float data to coprosessor
 */
u32 XMadgwick_Writef_m_Words(XMadgwick *InstancePtr, int offset, float *data, int length){
    Xil_AssertNonvoid(InstancePtr != NULL);
    Xil_AssertNonvoid(InstancePtr -> IsReady == XIL_COMPONENT_IS_READY);
    char *buffer;

    int i;

    if ((offset + length)*4 > (XMADGWICK_COPROCESSOR_BUS_ADDR_M_HIGH - XMADGWICK_COPROCESSOR_BUS_ADDR_M_BASE + 1))
        return 0;

    xil_printf("\nmagneto : \t\t");
    for (i = 0; i < length; i++) {
        *(float *)(InstancePtr->Coprocessor_bus_BaseAddress + XMADGWICK_COPROCESSOR_BUS_ADDR_M_BASE + (offset + i)*4) = *(data + i);
//        xil_printf("%f\t\t", *(data + i));
        sprintf(buffer, "%f\t\t", *(data + i));
        print(buffer);
    }
    return length;
}

/*
 *request magnetometer float data from coprosessor
 */
u32 XMadgwick_Readf_m_Words(XMadgwick *InstancePtr, int offset, float *data, int length);


/*
 *send quaternion float data to coprosessor
 */
u32 XMadgwick_Writef_q_Words(XMadgwick *InstancePtr, int offset, float *data, int length);

/*
 *request quaternion float data from coprosessor
 */
u32 XMadgwick_Readf_q_Words(XMadgwick *InstancePtr, int offset, float *data, int length){
    Xil_AssertNonvoid(InstancePtr != NULL);
    Xil_AssertNonvoid(InstancePtr -> IsReady == XIL_COMPONENT_IS_READY);

    int i;

    if ((offset + length)*4 > (XMADGWICK_COPROCESSOR_BUS_ADDR_Q_HIGH - XMADGWICK_COPROCESSOR_BUS_ADDR_Q_BASE + 1))
        return 0;

    xil_printf("\nq : \t\t");
    for (i = 0; i < length; i++) {
        *(data + i) = *(float *)(InstancePtr->Coprocessor_bus_BaseAddress + XMADGWICK_COPROCESSOR_BUS_ADDR_Q_BASE + (offset + i)*4);
        xil_printf("%f\t\t", *(data + i));
    }
    return length;
}

/*
 *send euler float data to coprosessor
 */
u32 XMadgwick_Writef_euler_Words(XMadgwick *InstancePtr, int offset, float *data, int length);

/*
 *request euler float data from coprosessor
 */
u32 XMadgwick_Readf_euler_Words(XMadgwick *InstancePtr, int offset, float *data, int length){
    Xil_AssertNonvoid(InstancePtr != NULL);
    Xil_AssertNonvoid(InstancePtr -> IsReady == XIL_COMPONENT_IS_READY);

    int i;

    if ((offset + length)*4 > (XMADGWICK_COPROCESSOR_BUS_ADDR_EULER_HIGH - XMADGWICK_COPROCESSOR_BUS_ADDR_EULER_BASE + 1))
        return 0;

    xil_printf("\nq : \t\t");
    for (i = 0; i < length; i++) {
        *(data + i) = *(float *)(InstancePtr->Coprocessor_bus_BaseAddress + XMADGWICK_COPROCESSOR_BUS_ADDR_EULER_BASE + (offset + i)*4);
        xil_printf("%f\t\t", *(data + i));
    }
    return length;
}
