/*
 * C++ Application
 */


#include "SDcard.h"
#include "platform.h"
#include "platform_config.h"
#include "sensor.h"

#include <stdio.h>
#include "platform.h"
#include "xil_printf.h"
/*
 * Several BSP (and standard C) header files need to be included
 */
#include <stdlib.h> // Standard C functions, e.g. exit()
#include <stdbool.h> // Provides a Boolean data type for ANSI/ISO-C
#include "xparameters.h" // Parameter definitions for processor peripherals
#include "xscugic.h" // Processor interrupt controller device driver
#include "xmadgwick.h" // Device driver for HLS HW block

#define offset 0
/*
 * Define variables for the HLS block and interrupt controller instance data. The variables
 * will be passed to driver API calls as handles in the respective hardware.
 */
XMadgwick HlsMadgwick;	// HLS Madgwick HW instance
XScuGic ScuGic;		//Interrupt Controller Instance

/*
 * Define global variables to interface with the interrupt service routine (ISR).
 */
volatile static int RunHlsMadgwick = 0;
volatile static int ResultAvailHlsMadgwick = 0;

/*
 * Define a function to wrap all run-once API initialization function calls for the HLS block.
 */
int hls_madgwick_init(XMadgwick *hls_madgwickPtr){
	XMadgwick_Config *cfgPtr;
	int status;
	cfgPtr = XMadgwick_LookupConfig(XPAR_MADGWICK_0_DEVICE_ID);	//Obtain the configuration information of the device by ID.
	if (!cfgPtr) {
		print("ERROR: Lookup of accelerator configuration failed.\n\r");
		return XST_FAILURE;
	}
	/*
	 * Initialize a device when an MMU is used in the system. In such a case the effective address
	 * of the AXI4-Lite slave is different from that defined in xparameters.h and API is required to
	 * initialize the device.
	 */
	status = XMadgwick_CfgInitialize(hls_madgwickPtr, cfgPtr);
	if (status != XST_SUCCESS) {
		print("ERROR: Could not initialize accelerator.\n\r");
		return XST_FAILURE;
	}
	return status;
}

/*
 * Define a helper function to wrap the HLS block API calls required to enable its interrupt
 * and start the block.
 */
void hls_madgwick_start(void *InstancePtr){
	XMadgwick *pAccelerator = (XMadgwick *)InstancePtr; //hold the IP instance pointer
	/*
	 * Enable the interrupt source. There may be at most 2 interrupt sources (source 0 for ap_done
	 * and source 1 for ap_ready)
	 */
	XMadgwick_InterruptEnable(pAccelerator,1);
	/*
	 * Enable the interrupt output. Interrupt functions are available only if there is ap_start.
	 */
	XMadgwick_InterruptGlobalEnable(pAccelerator);
	/*
	 * Start the device. This function will assert the ap_start port on the device. Available only
	 * if there is ap_start port on the device
	 */
	XMadgwick_Start(pAccelerator);
}

/*
 * An interrupt service routine is required in order for the processor to respond to an interrupt
 * generated by a peripheral.
 *
 * Each peripheral with an interrupt attached to the PS must have an ISR defined and
 * registered with the PS’s interrupt handler.
 *
 * The ISR is responsible for clearing the peripheral’s interrupt and, in this example, setting a
 * flag that indicates that a result is available for retrieval from the peripheral. In general, ISRs
 * should be designed to be lightweight and as fast as possible, essentially doing the
 * minimum necessary to service the interrupt. Tasks such as retrieving the data should be left
 * to the main application code.
 */
void hls_macc_isr(void *InstancePtr){
	XMadgwick *pAccelerator = (XMadgwick *)InstancePtr;
	//Disable the global interrupt
	XMadgwick_InterruptGlobalDisable(pAccelerator);
	//Disable the local interrupt
	XMadgwick_InterruptDisable(pAccelerator,0xffffffff);
	// clear the local interrupt
	XMadgwick_InterruptClear(pAccelerator,1);
	ResultAvailHlsMadgwick = 1;
	// restart the core if it should run again
	if(RunHlsMadgwick){
		hls_madgwick_start(pAccelerator);
	}
}

/*
 * Define a routine to setup the PS interrupt handler and register the HLS peripheral’s ISR.
 */
int setup_interrupt(){
	//This functions sets up the interrupt on the ARM
	int result;
	XScuGic_Config *pCfg = XScuGic_LookupConfig(XPAR_SCUGIC_SINGLE_DEVICE_ID);
	if (pCfg == NULL){
		print("Interrupt Configuration Lookup Failed\n\r");
		return XST_FAILURE;
	}
	result = XScuGic_CfgInitialize(&ScuGic,pCfg,pCfg->CpuBaseAddress);

	if(result != XST_SUCCESS){
		return result;
	}

	// self-test
	result = XScuGic_SelfTest(&ScuGic);
	if(result != XST_SUCCESS){
		return result;
	}

	// Initialize the exception handler
	Xil_ExceptionInit();
	// Register the exception handler
	//print("Register the exception handler\n\r");
	Xil_ExceptionRegisterHandler(XIL_EXCEPTION_ID_INT, (Xil_ExceptionHandler)XScuGic_InterruptHandler,&ScuGic);
	//Enable the exception handler
	Xil_ExceptionEnable();
	// Connect the Adder ISR to the exception table
	//print("Connect the Adder ISR to the Exception handler table\n\r");
	result = XScuGic_Connect(&ScuGic, XPAR_FABRIC_MADGWICK_0_INTERRUPT_INTR,
	(Xil_InterruptHandler)hls_macc_isr,&HlsMadgwick);

	if(result != XST_SUCCESS){
		return result;
	}

	//print("Enable the Adder ISR\n\r");
	XScuGic_Enable(&ScuGic,XPAR_FABRIC_MADGWICK_0_INTERRUPT_INTR);
	return XST_SUCCESS;
}

/*
 * Define a software model of the HLS hardware functionality with which you can compare
 * reference results.
 */

/*
 * Modify main() to use the HLS device driver API and the functions defined above to test
 * the HLS peripheral hardware
 */
int main()
{
	print("Program to test communication with HLS Madgwick peripheral in PL\n\r");
	float *q, *e;
	int status;
	char * buff;

	//Setup the matrix mult
	status = hls_madgwick_init(&HlsMadgwick);
	if(status != XST_SUCCESS){
		print("HLS peripheral setup failed\n\r");
		exit(-1);
	}

	//Setup the interrupt
	status = setup_interrupt();
	if(status != XST_SUCCESS){
		print("Interrupt setup failed\n\r");
		exit(-1);
	}

	//set the input parameters of the HLS block
//	XHls_macc_Set_a(&HlsMacc, a);
//	XHls_macc_Set_b(&HlsMacc, b);
//	XHls_macc_Set_accum_clr(&HlsMacc, 1);
	for (int i=0; i<5;i++){
		XMadgwick_Set_periode(&HlsMadgwick, 512);
		status = XMadgwick_Write_g_Words(&HlsMadgwick, offset, (int*) &gyro[i], 3);
		if(status != 3){
			print("initializing gyroscope failed\n\r");
			exit(-1);
		}
		status = XMadgwick_Write_a_Words(&HlsMadgwick, offset, (int*) &accelero[i], 3);
		if(status != 3){
			print("initializing accelerometer failed\n\r");
			exit(-1);
		}
		status = XMadgwick_Write_m_Words(&HlsMadgwick, offset, (int*) &magneto[i], 3);
		if(status != 3){
			print("initializing magnetometer failed\n\r");
			exit(-1);
		}
		if (XMadgwick_IsReady(&HlsMadgwick))
			print("HLS peripheral is ready. Starting... ");
		else {
			print("!!! HLS peripheral is not ready! Exiting...\n\r");
			exit(-1);
		}

		if (1) { // use interrupt
			hls_madgwick_start(&HlsMadgwick);
			while(!ResultAvailHlsMadgwick)
				; // spin
//			res_hw = Xhls_macc_GetAccum(&HlsMacc);
			XMadgwick_Read_euler_Words(&HlsMadgwick, offset, (int*) &e, 3);
			XMadgwick_Read_q_Words(&HlsMadgwick, offset, (int*) &q, 4);
			print("Interrupt received from HLS HW.\n\r");
		}
		else { // Simple non-interrupt driven test
			XMadgwick_Start(&HlsMadgwick);
			do {
				XMadgwick_Read_euler_Words(&HlsMadgwick, XMADGWICK_COPROCESSOR_BUS_ADDR_EULER_BASE, (int*) &e, 3);
				XMadgwick_Read_q_Words(&HlsMadgwick, XMADGWICK_COPROCESSOR_BUS_ADDR_Q_BASE, (int*) &q, 4);
//				res_hw = XHls_macc_Get_accum(&HlsMacc);
			} while (!XMadgwick_IsReady(&HlsMadgwick));
			print("Detected HLS peripheral complete. Result received.\n\r");
		}
		xil_printf("no %d : %f\t%f\t%f\t%f\t%f\t%f\t%f\n", i, q[0], q[1], q[2], q[3], e[0], e[1], e[2]);

	}
	cleanup_platform();
	return status;
}
